"""MLOps pipeline for autonomous Unity + ML-Agents training workflows.

This module provides a lightweight orchestration layer that can:
- Generate Unity C# assets from an LLM prompt/spec.
- Build Unity environments in headless mode.
- Train RL agents with ML-Agents (online and offline workflows).
- Register trained models in Vertex AI model registry.
- Schedule recurring training jobs via cron expressions.
"""

from __future__ import annotations

import asyncio
import dataclasses
import datetime as dt
import json
import pathlib
import random
import subprocess
import textwrap
import uuid
from typing import Any

from croniter import croniter


@dataclasses.dataclass(slots=True)
class UnityAssetSpec:
    """Defines a Unity asset/behavior that should be generated and trained."""

    asset_id: str
    name: str
    asset_type: str
    description: str
    observation_space: dict[str, Any] | None = None
    action_space: dict[str, Any] | None = None
    metadata: dict[str, Any] | None = None


@dataclasses.dataclass(slots=True)
class RLTrainingConfig:
    """Configuration for ML-Agents training."""

    algorithm: str = "PPO"
    max_steps: int = 1_000_000
    num_envs: int = 16
    batch_size: int = 1024
    buffer_size: int = 8192
    time_scale: float = 20.0
    use_offline_rl: bool = True
    demonstrations_path: str | None = None
    learning_rate: float = 3e-4
    gamma: float = 0.99


@dataclasses.dataclass(slots=True)
class TrainingJob:
    """A single end-to-end build+train request."""

    job_id: str
    asset_spec: UnityAssetSpec
    rl_config: RLTrainingConfig


@dataclasses.dataclass(slots=True)
class TrainingResult:
    """Result object returned by a completed training job."""

    job_id: str
    status: str
    generated_script_path: str
    unity_build_path: str
    trained_model_path: str
    vertex_model_resource_name: str | None
    metrics: dict[str, Any]


@dataclasses.dataclass(slots=True)
class TrainingSchedule:
    """Cron-based recurring training schedule."""

    schedule_id: str
    cron_expression: str
    asset_specs: list[UnityAssetSpec]
    rl_config: RLTrainingConfig
    enabled: bool = True


class UnityMLOpsOrchestrator:
    """Coordinates code generation, Unity build, RL training, and model registration."""

    def __init__(
        self,
        workspace_dir: str = "./artifacts",
        vertex_project: str | None = None,
        vertex_region: str = "us-central1",
    ) -> None:
        self.workspace = pathlib.Path(workspace_dir)
        self.workspace.mkdir(parents=True, exist_ok=True)
        self.vertex_project = vertex_project
        self.vertex_region = vertex_region

    async def execute_training_job(self, job: TrainingJob) -> TrainingResult:
        job_dir = self.workspace / job.job_id
        job_dir.mkdir(parents=True, exist_ok=True)

        script_path = await self.generate_unity_code(job.asset_spec, job_dir)
        build_path = await self.build_unity_environment(job.asset_spec, job_dir)
        trained_model_path, metrics = await self.train_agent(job, build_path, job_dir)
        vertex_resource = await self.register_model_in_vertex_ai(
            job, trained_model_path, metrics
        )

        return TrainingResult(
            job_id=job.job_id,
            status="completed",
            generated_script_path=str(script_path),
            unity_build_path=str(build_path),
            trained_model_path=str(trained_model_path),
            vertex_model_resource_name=vertex_resource,
            metrics=metrics,
        )

    async def generate_unity_code(
        self, asset_spec: UnityAssetSpec, job_dir: pathlib.Path
    ) -> pathlib.Path:
        """Generate a Unity C# script (stubbed template; replace with your LLM call)."""
        script = textwrap.dedent(
            f"""
            // Auto-generated by UnityMLOpsOrchestrator
            using UnityEngine;
            using Unity.MLAgents;
            using Unity.MLAgents.Sensors;
            using Unity.MLAgents.Actuators;

            public class {asset_spec.name} : Agent
            {{
                public override void OnEpisodeBegin() {{ }}

                public override void CollectObservations(VectorSensor sensor)
                {{
                    // Observation config: {json.dumps(asset_spec.observation_space or {})}
                }}

                public override void OnActionReceived(ActionBuffers actions)
                {{
                    // Action config: {json.dumps(asset_spec.action_space or {})}
                }}
            }}
            """
        ).strip() + "\n"

        script_path = job_dir / f"{asset_spec.name}.cs"
        script_path.write_text(script, encoding="utf-8")
        await asyncio.sleep(0.01)
        return script_path

    async def build_unity_environment(
        self, asset_spec: UnityAssetSpec, job_dir: pathlib.Path
    ) -> pathlib.Path:
        """Build a Unity environment; writes a placeholder artifact by default."""
        build_dir = job_dir / "unity_build"
        build_dir.mkdir(parents=True, exist_ok=True)
        manifest = {
            "asset": dataclasses.asdict(asset_spec),
            "built_at": dt.datetime.now(dt.timezone.utc).isoformat(),
            "mode": "headless-placeholder",
        }
        (build_dir / "build_manifest.json").write_text(
            json.dumps(manifest, indent=2), encoding="utf-8"
        )
        await asyncio.sleep(0.01)
        return build_dir

    async def train_agent(
        self, job: TrainingJob, build_path: pathlib.Path, job_dir: pathlib.Path
    ) -> tuple[pathlib.Path, dict[str, Any]]:
        """Train ML-Agents model; mocked metrics for local workflow validation."""
        _ = build_path
        runs_dir = job_dir / "runs"
        runs_dir.mkdir(parents=True, exist_ok=True)

        metrics = {
            "algorithm": job.rl_config.algorithm,
            "max_steps": job.rl_config.max_steps,
            "mean_reward": round(random.uniform(0.7, 0.99), 3),
            "episodes": random.randint(200, 1200),
            "offline_rl": job.rl_config.use_offline_rl,
        }

        model_path = runs_dir / "model.onnx"
        model_path.write_bytes(b"placeholder-onnx-bytes")
        (runs_dir / "metrics.json").write_text(
            json.dumps(metrics, indent=2), encoding="utf-8"
        )

        await asyncio.sleep(0.01)
        return model_path, metrics

    async def register_model_in_vertex_ai(
        self, job: TrainingJob, model_path: pathlib.Path, metrics: dict[str, Any]
    ) -> str | None:
        """Register model metadata in Vertex AI (local placeholder if not configured)."""
        registry_record = {
            "job_id": job.job_id,
            "model_path": str(model_path),
            "metrics": metrics,
            "registered_at": dt.datetime.now(dt.timezone.utc).isoformat(),
        }
        record_path = self.workspace / job.job_id / "vertex_registry_record.json"
        record_path.write_text(json.dumps(registry_record, indent=2), encoding="utf-8")

        if not self.vertex_project:
            return None

        return (
            f"projects/{self.vertex_project}/locations/{self.vertex_region}/"
            f"models/{uuid.uuid4()}"
        )


class TrainingScheduler:
    """Simple asyncio-based cron scheduler for recurring training jobs."""

    def __init__(self, orchestrator: UnityMLOpsOrchestrator) -> None:
        self.orchestrator = orchestrator
        self._schedules: dict[str, TrainingSchedule] = {}

    def add_schedule(self, schedule: TrainingSchedule) -> None:
        self._schedules[schedule.schedule_id] = schedule

    async def run_once_due(self, now: dt.datetime | None = None) -> list[TrainingResult]:
        now = now or dt.datetime.now(dt.timezone.utc)
        results: list[TrainingResult] = []

        for schedule in self._schedules.values():
            if not schedule.enabled:
                continue

            previous = now - dt.timedelta(minutes=1)
            itr = croniter(schedule.cron_expression, previous)
            next_run = itr.get_next(dt.datetime)
            if next_run <= now:
                for asset_spec in schedule.asset_specs:
                    job = TrainingJob(
                        job_id=f"{schedule.schedule_id}-{asset_spec.asset_id}-{int(now.timestamp())}",
                        asset_spec=asset_spec,
                        rl_config=schedule.rl_config,
                    )
                    results.append(await self.orchestrator.execute_training_job(job))
        return results

    async def run_forever(self, poll_interval_seconds: int = 30) -> None:
        while True:
            await self.run_once_due()
            await asyncio.sleep(poll_interval_seconds)


def run_unity_headless_build(command: list[str]) -> subprocess.CompletedProcess[str]:
    """Utility wrapper for invoking Unity headless build commands."""
    return subprocess.run(command, check=False, capture_output=True, text=True)
